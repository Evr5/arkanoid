\documentclass{article}
\usepackage[margin=3.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{titling} % Pour personnaliser l'emplacement des éléments liés au titre
\usepackage[T1]{fontenc}
\usepackage{enumitem}
\usepackage{hyperref}


\title{Rapport sur le projet de Langage de Programmation : Arkanoïd}
\date{5 janvier 2025}


\begin{document}

\maketitle
\vspace{-1cm} % Réduire l'espace entre le titre et le tableau
\begin{table}[h!]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Prénom & Nom & Matricule \\ \hline
        Lucas  & Verbeiren & 000591223 \\ \hline
        Ethan  & Van Ruyskensvelde & 000589640 \\ \hline
    \end{tabular}
    \label{tab:my_label}
\end{table}

\tableofcontents % Table des matières

\newpage

\section{Introduction}

Dans le cadre de ce projet, nous avons dû réaliser une version fonctionnelle
avec une interface graphique du célèbre jeu \texttt{Arkanoid} en utilisant les
principes de la programmation orientée objet. \\

Le développement a été réalisé en \texttt{C++} avec l'utilisation de la
bibliothèque \texttt{Allegro} pour l'interface graphique. Le projet a été
réalisé à l'aide du \texttt{Modèle-Vue-Contrôleur} (MVC) afin de séparer
clairement les différentes responsabilités du code. \\

L’objectif principal est d’implémenter un niveau fonctionnel avec les
différentes mécaniques de jeu :

\begin{itemize}

    \item Déplacement de la raquette,

    \item Rebonds de la balle,

    \item Gestion des briques,

    \item Gestion des vies,

    \item Gestion du score,

    \item Niveaux multiples,

    \item Briques colorées,

    \item Bonus.

\end{itemize}

Enfin, ce projet vise également à montrer notre compréhension des concepts
principaux de la programmation orientée objet et notre capacité à structurer un
projet complet. À travers cette réalisation, nous cherchons à fournir un
programme robuste, modulaire et bien documenté.

\section{Tâches accomplies}

Pour ce projet, nous avons réalisé toutes les tâches de base, c'est-à-dire :

\begin{itemize}

    \item Rebond correct de la balle sur les différentes surfaces comme les
        briques, les murs et la raquette,

    \item Déplacement de la raquette,

    \item Un niveau comportant 8 lignes de 14 briques,

    \item Un affichage du score qui est mit à jour en gagnant 1 point par
        brique cassée. Si le joueur a cassé toutes les briques, un message de
        victoire est affiché,

    \item Un système de vie où le joueur a 3 vies maximum par partie. S'il les
        perd toutes, un message de défaite est affiché.

\end{itemize}

Nous avons également effectué ces différentes tâches additionnelles :

\begin{itemize}

    \item Un système de niveau où chaque niveau est encodé dans un fichier
        '.txt', avec la possibilité d'encoder un bonus pour une brique,

    \item Déplacement de la raquette avec la souris,

    \item Des briques avec différentes couleurs et où chaque couleur fait
        remporté des points différents. De plus, nous sauvegardons après chaque
        partie le meilleur score dans un fichier 'score.txt' et le meilleur
        score est affiché en cours de partie. Nous avons également implémenté
        une touche qui permet de réinitialiser le meilleur score,

    \item L'ajout de briques argentées et dorées. Une brique dorée ne peut
        jamais être cassée et une brique argentée a besoin d'être touché deux
        fois par la balle pour pouvoir être cassée, 

    \item Le bonus qui permet d'agrandir la raquette lorsque le joueur attrape
        la capsule bleue,

    \item Le bonus qui permet de ralentir la vitesse de la balle lorsque le
        joueur attrape la capsule orange,

    \item Le bonus qui permet de gagner une vie en attrapant la capsule grise,

    \item Le bonus qui permet de tirer un laser en attrapant la capsule
        magenta,

    \item Le bonus qui permet de diviser la balle en trois instances d'elle
        même si le joueur attrape la capsule cyan.

\end{itemize}



\section{Interface des différentes classes, leurs rôles et liens avec les
autres classes}

% TODO: toutes les classes de view et le controller
% TODO: Log
% TODO: Vec2

\subsection{GameBoard}

La classe GameBoard est l'élément central du modèle. Elle coordonne et fait
évoluer les autres composants du modèle au fil du temps. Le tableau
\ref{tab:responsabilites} détaille ces composants ainsi que les classes
associées à chacun :

% TODO: lazer

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Composant du modèle}        & \textbf{Classe}   \\ \hline
        Le score                            & ScoreManager      \\ \hline
        Le compteur de vie                  & LifeCounter       \\ \hline
        Le bonus actif                      & Bonus             \\ \hline
        Les capsules de bonus qui tombent   & BonusPill         \\ \hline
        Les lazers                          & Lazer             \\ \hline
        La raquette                         & Racket            \\ \hline
        Les bordures du plateau de jeu      & Border            \\ \hline
        Les briques                         & Brick             \\ \hline
        Les balles                          & Ball              \\ \hline
    \end{tabular}
    \caption{Correspondance entre les composants du modèle et les classes.}
    \label{tab:responsabilites}
\end{table}

%TODO: change controller
Le contrôleur qui possède l'horloge du jeu doit pouvoir signaler à la
GameBoard de mettre à jour les composants du modèle et combien de temps s'est
écoulé entre cette mise à jour et la précédente. Cela est implémenté via la
méthode \texttt{update}. Chaque fois que celle-ci est appelée à un instant $T$,
avec un paramètre $deltaT$, \texttt{GameBoard} met à jour tous les composants
du modèle à l'état correspondant à l'instant \(T + deltaT\).

\subsection{Vec2}

La classe \texttt{Vec2} représente un vecteur à deux dimensions. Celle-ci
implémente les opérateurs usuels des vecteurs, e.g. l'addition, la soustraction.

\subsection{RectangleShape}

La classe \texttt{RectangleShape} est utilisée pour représenter n'importe quel
objet rectangulaire, tel qu'une brique ou la raquette.

Son interface permet de :
\begin{itemize}

    \item Modifier le centre, la hauteur et la largeur du rectangle.

    \item Obtenir différentes informations sur le rectangle, e.g. la largeur,
        le centre.

    \item Vérifier si une superposition a lieu avec un autre rectangle.

\end{itemize}

\subsection{Bounceable}

La classe \texttt{Bounceable} représente un objet rectangulaire sur lequel la
balle peut rebondir. Puisque toutes les instances de cette classes sont
rectangulaires, celle-ci hérite de \texttt{RectangularShape}. 

Par défaut, l'effet de rebond des \texttt{Bounceable}'s consiste simplement à
inverser l'axe $x$ et/ou $y$ du vecteur directeur de la balle en fonction du
type de rebond (rebond sur un coin, une surface verticale ou horizontale). Le
type de rebond s'obtient via la méthode \texttt{getBounceType} renvoyant un
enuméré \texttt{BounceType} représentant ces trois types de rebond. Cependant,
chaque \texttt{Bounceable}'s peut modifier l'effet de rebond par défaut, qui
est donné à tous les \texttt{Bounceable}'s, et ce en "overridant" la méthode
\texttt{getDirVecAfterBounce}.

\subsection{Briques}

La classe abstraite \texttt{AbstractBrick} représente une brique. Puisque la
balle peut rebondir sur les briques, \texttt{AbstractBrick} hérite de
\texttt{Bounceable}. Une brique est définie comme un type de
\texttt{Bounceable} ayant:

\begin{itemize}

    \item Une couleur, directemment liée au nombre de points qu'elle rapporte
        au joueur, une fois que celui-ci la détruit.

    \item Une durabilité, représentant le nombre de coup que celle-ci peut
        encore subir avant d'être détruite.

    \item Le type type de bonus qu'elle contient.

\end{itemize}

Afin d'associer à sa couleur un nombre de points rapportés lors de la
destruction, nous utilisons l'énuméré \texttt{AbstractBrick::Color}. \\

Lorsque la \texttt{GameBoard} détecte qu'une balle rebondit sur la brique, elle
doit signaler à la brique qu'elle a été touchée. Ceci est implémenté via la
méthode \texttt{hit} servant à décrémenter la durabilité et, si celle-ci est
détruite, renvoyer le type de bonus que la brique contenait.

Les briques dorées ne pouvant pas être détruites contrairement aux autres, nous
avons créé deux classes héritant de \texttt{brick}:

\begin{itemize}

    \item \texttt{BasicBrick} Pour les briques implémentant les caractérstiques
        d'une brique simple, i.e. qui peut être détruite.

    \item \texttt{GoldBrick} Pour les briques dorées qui ne peuvent pas être détruite.

\end{itemize}

L'interface qu'offrent \texttt{BasicBrick} et \texttt{GoldBrick} est exactement
la même interface que celle de \texttt{AbstractBrick}. Afin de pouvoir profiter du
polymorphisme, nous implémentons une "méthode-usine" ("factory") renvoyant un
pointeur de brique pouvant pointer vers une \texttt{BasicBrick} ou une
\texttt{GoldBrick}.

\subsection{Border}

La classe \texttt{Border} représente les trois bordures du plateau de jeu sur
lesquelles les balles rebondissent (en haut, à gauche et à droite).
\texttt{Border} hérite de \texttt{Bounceable} et n'implémente aucune méthode
particulière. 

\subsection{Racket}

La classe \texttt{Racket} représente la raquette. Puisque les balles peuvent rebondir
dessus, celle-ci hérite de \texttt{Bounceable}.

Puisque dans le jeu, la raquette doit être déplacée uniquement latéralement,
nous fournissons le setter \texttt{setCenterX}, spécifiquement dédié à cela.

La classe \texttt{Racket} modifie l'effet de rebond par défaut de
\texttt{Bounceable} en surchargeant la méthode \texttt{getDirVecAfterBounce}.
Cela permet d'ajouter l'effet de variation de l'angle entre la balle et
l'horizontale en fonction de la distance par rapport au centre de la raquette.

\subsection{Ball}

La classe \texttt{Ball} représente une balle du jeu. Celle-ci possède
essentiellement une position, un rayon, et une vitesse, un vecteur directeur.
Nous nous assurons que la balle garde une vitesse de déplacement directement
proportionnelle à son attribut vitesse, en gardant le vecteur directeur toujours
normalisé, c'est-à-dire que son module vaut 1. Le scalaire vitesse est donc le
seul pouvant influencer la vitesse de déplacement de la balle.

La méthode \texttt{checkCollision} permet de vérifier si la balle est rentrée en
collision avec un \texttt{RectangleShape}. Cette méthode est utilisée par la
\texttt{GameBoard} au moment de trouver les collisions qui ont eu lieu à un
instant $T$. La méthode \texttt{collide} également appelée par
\texttt{GameBoard} permet ensuite de résoudre la collision avec un
\texttt{RectangleShape}. "Résoudre la collision" voulant dire: Sortir la balle
du Bounceable et appliquer l'effet de rebond spécifique au \texttt{Bounceable}
sur le vecteur directeur de la balle.

La méthode \texttt{update} prenant un paramètre représentant une durée
$deltaTime$ permet de mettre à jour la position de la balle à l'instant $T +
deltaTime$.

\subsection{BonusType}

L'énuméré contient les différents types de bonus implémentés, ainsi que la
valeur \texttt{None}, représentant l'absence de bonus.

\subsection{AbstractTimedBonus}

Les bonus à effet à durée limitée sont gérés par les classes
\texttt{BasicTimedBonus} et \texttt{SlowDownBonus}, qui héritent de la classe
abstraite \texttt{AbstractTimedBonus}. Cette dernière fournit une structure
commune avec un attribut \texttt{BonusType} (indiquant le type de bonus) ainsi qu'une
interface pour notifier le bonus de :
\begin{itemize}

    \item L'écoulement d'une durée \texttt{deltaT}

    \item Réappliquer le bonus (Ceci est nécessaire uniquement pour les bonus
        "SlowDown" car les effets sont cumulables).

\end{itemize}

\subsection{BasicTimedBonus}

La classe \texttt{BasicTimedBonus} hérite de \texttt{AbstractTimedBonus} et
gère le temps d'activité de celui-ci. Elle implémente la méthode
\texttt{update} de l'interface de \texttt{AbstractTimedBonus}, permettant de
diminuer le temps restant du bonus d'une durée donnée. Nous l'utilisons pour
les bonus suivants: "WideRacket" et "Lazer". Nous avions l'intention de
l'utiliser également pour le bonus "Attraper" mais nous ne sommes pas
parvenus à implémenter celui-ci dans les délais du projet.

\subsection{SlowDownBonus} 

Le bonus "SlowDown" est cummulable, contrairement aux autres. Cela signifie que
si le joueur attrappe un "SlowDown" alors qu'un ou plusieurs "SlowDown" étaient
déjà actifs, la balle doit encore plus ralentir.
La méthode \texttt{getSlowDownFactor} est spécifique à celui-ci et permet d'obtenir la
valeur par laquelle la vitesse de base de la balle doit être divisée pour
obtenir sa vitesse avec cette configuration de bonus "SlowDown". Cette valeur
est proportionnelle à la somme des temps restants pour tous les "SlowDown"
actifs.

Le fait qu'il soit cumulable contrairement aux autres bonus est la raison pour
laquelle nous choisissons d'implémenter les bonus à l'aide de 3 classes dont
une classe abstraite permettant d'unifier le comportement commun des deux
autres.

\subsection{BonusPill}

La classe \texttt{BonusPill} représente une capsule/pillule de bonus contenant
un \texttt{BonusType}. Celle-ci étant rectangulaire mais ne laissant pas la
balle rebondir dessus, elle hérite seulement de \texttt{RectangleShape}. Elle
possède également une vitesse de descente. La méthode isOverlapping, héritée de
\texttt{RectangleShape} permet de vérifier si la pillule est rentrée en
collision avec un autre \texttt{RectangleShape}. Nous utilisons cette méthode
sur la raquette afin de savoir si la raquette a attrappé la \texttt{BonusPill}.
La méthode \texttt{update} permet de faire descendre le bonus de la distance
qu'il aurait pacourut après \texttt{deltaTime} secondes.

\subsection{ScoreManager}

La classe \texttt{ScoreManager} gère et centralise les informations concernant
le score, c'est à dire le meilleur score et le score du joueur à un instant T.

\subsection{LifeCounter}

La classe \texttt{LifeCounter} gère le nombre de vies du joueur. Toutefois, la
responsabilité de notifier les pertes et gains de vie au \texttt{LifeCounter}
revient à la \texttt{GameBoard}. Par exemple, lorsque le joueur n'a plus de
balle en jeu, \texttt{GameBoard} doit envoyer une message \texttt{LifeCounter}
pour décrémenter le nombre de vie.

\subsection{Lazer}

La classe \texttt{Lazer} représente un lazer tiré vers le haut et provenant de
la raquette. Celui-ci est de forme rectangulaire et ne fait pas rebondir la
balle, il hérite donc uniquement de \texttt{RectangleShape}. Celui-ci possède
une vitesse. Nous utilisons la méthode isOlverapping héritée de
\texttt{RectangleShape} afin de vérifier si le lazer a collisionné avec un
autre \texttt{RectangleShape}. La méthode \texttt{update} permet de faire
monter le bonus de la distance qu'il aurait pacourut après \texttt{deltaTime}
secondes.

\section{Logique du jeu}

Nous allons maintenant décrire en détail ce qui se passe dans notre code à
partir du moment où l'utilisateur lance le programme, et le moment où la balle
touche une brique pour la première fois. \\

Quand le jeu est lancé, la première chose que fait le programme est
d'initialiser les différentes classes nécessaires. En tout premier, il va créer
l'objet \textit{ControllerGame} qui permet de contrôler la grille du jeu et la
vue. Ensuite, il créera l'objet \textit{GameBoard} pour initialiser le modèle
qui permet d'avoir l'état de la grille avec les différents systèmes qui
permettent de la modifier. L'objet \textit{LevelManager} sera également créé.
Il permet de charger tous les différents niveaux en une fois, avec les murs, la
raquette et les briques qu'il passera à la grille (GameBoard). Après, il créera
aussi l'objet \textit{DisplayGame} qui gère la partie graphique du jeu. Il
initialisera \texttt{Allegro} pour pouvoir afficher une fenêtre. À chaque fois
que nous avons besoin d'afficher l'état du jeu, \textit{DisplayGame} ira
demander à \textit{GameBoard} l'état de la grille pour l'afficher. \\

Une fois que ces différents objets sont créés, le programme installera ce qu'il
faut pour pouvoir utiliser le clavier et la souris dans le jeu. Puis, il créera
une \textit{clock} qui permet d'avoir un \textit{tick} x fois par seconde pour
mettre à jour la grille du jeu et également afficher l'état du jeu à l'écran.
Nous avons séparé la vitesse de mise à jour de la grille du nombre d'images
affichées par Allegro chaque seconde. La grille sera mise à jour 500 fois par
seconde tandis qu' Allegro affichera une image à l'écran 125 fois par seconde.
\\

Une fois fait, le programme chargera le premier niveau et démarrera ensuite la
\textit{clock}. La grille sera mise à jour en vérifiant si la balle a cogné
contre quelque chose, puis le programme regardera si la partie est peut-être
perdue ou peut-être gagnée, et affichera à l'écran le jeu. Si des événements
arrivent dans la \textit{queue} d'Allegro, ils seront traités avant d'afficher
le jeu à l'écran.  \\

Si la balle a touché une brique, un calcul repositionnera la balle là où elle
devrait être et changera sa direction. Ensuite, le programme enlève une vie à
la brique, et si sa vie passe à 0, alors elle sera supprimée de la liste des
briques. Elle n'existera donc plus et ne sera plus affichée à l'écran.

\section{Modèle-Vue-Contrôleur}

Tout au long du développement du programme, nous avons essayé le plus possible
de respecter le modèle de conception \texttt{'Modèle-Vue-Contrôleur'}. En
effet, notre programme est divisé en trois parties distinctes : 

\begin{itemize}

    \item \texttt{Modèle}

    \item \texttt{Vue}

    \item \texttt{Contrôleur}

\end{itemize}

\subsection{Modèle}

Cette partie contient toute la logique pour la grille du jeu. Elle permet
d'avoir l'état de la grille et de la modifier. Elle ne possède donc rien qui
est lié à l'affichage comme Allegro. Elle permet de ne devoir uniquement gérer
la partie logique du jeu, sans devoir s'occuper d'afficher en plus l'état du
jeu. La classe \textit{GameBoard} représente l'état du jeu et possède une
méthode pour pouvoir être mise à jour.

\subsection{Vue}

La partie vue permet seulement d'afficher l'état de la grille à un moment
donné. La vue va demander au modèle son état pour l'afficher à l'écran à l'aide
de la bibliothèque Allegro. Elle ne peut donc en aucun cas modifier l'état du
jeu, donc le modèle. Toutes les méthodes de modification du modèle dans la
classe \textit{GameBoard} sont privées, ce qui garantit que la classe
\textit{DisplayGame} n'a aucun moyen de modifier \textit{GameBoard}. Les seules
méthodes publiques de \textit{GameBoard} sont des getters constants qui
assurent qu'aucune modification du modèle n'est possible.

\subsection{Contrôleur}

Cette troisième partie permet de contrôler le modèle en lui demandant de faire
certaines choses, ou en lui demandant de lui donner quelque chose. Le
contrôleur permet aussi de dire à la vue quand afficher quelque chose. Grâce à
lui, nous pouvons gérer le modèle et la vue en les séparant et les faire
fonctionner tous les deux, avec la garantie que la vue ne saura pas modifier le
modèle. C'est la classe \textit{ControllerGame} qui joue ce rôle. Elle possède
un \textit{shared pointer} vers \textit{GameBoard} pour lui demander de se
mettre à jour, et un \textit{shared pointer} vers \textit{DisplayGame} pour lui
demander d'afficher l'état du jeu.


\section{Conclusion}

Pour conclure ce rapport, nous dirons que ce projet nous a permis de développer
nos compétences en programmation orientée objet grâce au développement d'une
version fonctionnelle du jeu \texttt{Arkanoid}. L’utilisation du modèle
\texttt{Modèle-Vue-Contrôleur} a été essentielle pour nous répartir les tâches
entre nous deux, et pour structurer notre code et garantir une séparation
claire des responsabilités entre la logique du jeu, l’affichage du jeu, et le
contrôle des événements. \\

Le fait que ce projet soit un jeu avec une interface graphique nous a également
permis de prendre du plaisir à le réaliser tout en approfondissant notre
connaissance du langage \texttt{C++}.  \\

Cette expérience nous a non seulement permis de développer un programme abouti,
mais également d’affiner nos compétences en conception, en programmation et en
travail d'équipe.


\end{document}

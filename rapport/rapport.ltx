\documentclass{article}
\usepackage[margin=3.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{titling} % Pour personnaliser l'emplacement des éléments liés au titre
\usepackage[T1]{fontenc}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}

\lstset{
    language=C++,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    stringstyle=\color{green}
    commentstyle=\color{gray},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    showspaces=false,
    showstringspaces=false,
    tabsize=4,
    breaklines=true,
    captionpos=b,
    frame=single,
}

\title{Rapport sur le projet de Langage de Programmation : Arkanoïd}
\date{5 janvier 2025}

\begin{document}

\maketitle
\vspace{-1cm} % Réduire l'espace entre le titre et le tableau
\begin{table}[h!]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Prénom & Nom & Matricule \\ \hline
        Lucas  & Verbeiren & 000591223 \\ \hline
        Ethan  & Van Ruyskensvelde & 000589640 \\ \hline
    \end{tabular}
    \label{tab:my_label}
\end{table}

\tableofcontents % Table des matières

\newpage

\section{Introduction}

Ce projet consiste à implémenter une version fonctionnelle du célèbre jeu
\texttt{Arkanoid} en utilisant les principes de la programmation orientée
objet. \\

Pour ce faire, nous utilisons le langage de programmation \texttt{C++} et la
bibliothèque \texttt{Allegro} pour l'interface graphique. Nous structurons le
projet en suivant les principes de l'architecture
\texttt{Modèle-Vue-Contrôleur} (MVC), afin de séparer clairement les
différentes responsabilités du code. \\

L’objectif principal est d’implémenter un niveau fonctionnel avec les
mécaniques de jeu suivantes :

\begin{itemize}

    \item Déplacement de la raquette

    \item Rebonds de la balle

    \item Gestion des briques

    \item Gestion des vies

    \item Gestion du score

    \item Niveaux multiples

    \item Briques colorées

    \item Bonus

\end{itemize}

Enfin, ce projet vise également à montrer notre compréhension des concepts
principaux de la programmation orientée objet et notre capacité à structurer un
projet complet. À travers cette réalisation, nous cherchons à fournir un
programme robuste, modulaire et bien documenté.

\section{Tâches accomplies}

Nous avons réalisé toutes les tâches de base, c'est-à-dire :

\begin{itemize}

    \item Rebond correct de la balle sur les différentes surfaces comme les
        briques, les murs et la raquette

    \item Déplacement de la raquette

    \item Un niveau comportant 8 lignes de 14 briques

    \item Un affichage du score qui est mit à jour en gagnant 1 point par
        brique cassée. Si le joueur a cassé toutes les briques, un message de
        victoire est affiché

    \item Un système de vie où le joueur a 3 vies maximum par partie. S'il les
        perd toutes, un message de défaite est affiché

\end{itemize}

Nous avons également effectué les tâches additionnelles suivantes :

\begin{itemize}

    \item Un système de niveau où chaque niveau est encodé dans un fichier
        '.txt', avec la possibilité d'encoder un bonus pour une brique.

    \item Déplacement de la raquette avec la souris.

    \item Des briques avec différentes couleurs et où chaque couleur fait
        remporté des points différents. De plus, nous sauvegardons après chaque
        partie le meilleur score dans un fichier 'score.txt' et le meilleur
        score est affiché en cours de partie. Nous avons également implémenté
        une touche qui permet de réinitialiser le meilleur score.

    \item L'ajout de briques argentées et dorées. Une brique dorée ne peut
        jamais être cassée et une brique argentée a besoin d'être touchée deux
        fois par la balle pour pouvoir être cassée.

    \item Le bonus qui permet d'agrandir la raquette lorsque le joueur attrape
        la capsule bleue.

    \item Le bonus qui permet de ralentir la vitesse de la balle lorsque le
        joueur attrape la capsule orange.

    \item Le bonus qui permet de gagner une vie en attrapant la capsule grise.

    \item Le bonus qui permet de tirer un laser en attrapant la capsule
        magenta.

    \item Le bonus qui permet d'attrapper et coller la balle sur la raquette en
        attrapant la capsule vert.

    \item Le bonus qui permet de diviser la balle en trois instances d'elle
        même si le joueur attrape la capsule cyan.

\end{itemize}

\section{Interface des différentes classes, leurs rôles et liens avec les
autres classes}

\subsection{Modèle}

Toutes les classes utilisées pour le modèle se trouvent dans le dossier
\texttt{src/model}.

\subsubsection{GameBoard}

La classe GameBoard est l'élément central du modèle. Elle coordonne et fait
évoluer les autres composants du modèle au fil du temps. Le tableau
\ref{tab:responsabilites} détaille ces composants ainsi que les classes
associées à chacun :

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Composant du modèle}        & \textbf{Classe}   \\ \hline
        Le score                            & ScoreManager      \\ \hline
        Le compteur de vie                  & LifeCounter       \\ \hline
        Le bonus actif                      & Bonus             \\ \hline
        Les capsules de bonus qui tombent   & BonusPill         \\ \hline
        Les lazers                          & Lazer             \\ \hline
        La raquette                         & Racket            \\ \hline
        Les bordures du plateau de jeu      & Border            \\ \hline
        Les briques                         & Brick             \\ \hline
        Les balles                          & Ball              \\ \hline
    \end{tabular}
    \caption{Correspondance entre les composants du modèle et les classes.}
    \label{tab:responsabilites}
\end{table}

Le contrôleur qui possède l'horloge du jeu doit pouvoir signaler à la GameBoard
de mettre à jour les composants du modèle et combien de temps s'est écoulé
entre cette mise à jour et la précédente. Nous implémentons cela via la méthode
\texttt{update} de \texttt{GameBoard}: Chaque fois que celle-ci est appelée à
un instant $T$, avec en paramètre une durée $deltaT$, \texttt{GameBoard} met à
jour tous les composants du modèle à l'état correspondant à l'instant \(T +
deltaT\).

\subsubsection{Vec2}

La classe \texttt{Vec2} représente un vecteur à deux dimensions. Celle-ci
implémente les opérateurs usuels des vecteurs, e.g. l'addition, la
soustraction. Cette classe ne représente pas un élément du jeu directemment.
Nous l'utilisons pour représenter des points et des vecteurs dans le plan.

\subsubsection{RectangleShape}

La classe \texttt{RectangleShape} est utilisée pour représenter n'importe quel
objet rectangulaire, e.g. une brique, la raquette.

Son interface permet de :
\begin{itemize}

    \item Modifier le centre, la hauteur et la largeur du rectangle.

    \item Obtenir différentes informations sur le rectangle, e.g. la largeur,
        le centre.

    \item Vérifier si une superposition a lieu avec un autre rectangle.

\end{itemize}

\subsubsection{Bounceable}

La classe \texttt{Bounceable} représente un objet rectangulaire sur lequel la
balle peut rebondir. Puisque toutes les instances de cette classes sont
rectangulaires, celle-ci hérite de \texttt{RectangularShape}.  \\

Par défaut, l'effet de rebond des \texttt{Bounceable}'s consiste simplement à
inverser l'axe $x$ et/ou $y$ du vecteur directeur de la balle en fonction du
type de rebond (rebond sur un coin, une surface verticale ou horizontale). Le
type de rebond s'obtient via la méthode \texttt{getBounceType} renvoyant un
enuméré \texttt{BounceType} représentant ces trois types de rebond. Cependant,
chaque \texttt{Bounceable}'s peut modifier l'effet de rebond par défaut, qui
est donné à tous les \texttt{Bounceable}'s, et ce en "overridant" la méthode
\texttt{getDirVecAfterBounce}.

\subsubsection{Briques}

La classe abstraite \texttt{AbstractBrick} représente une brique. Puisque la
balle peut rebondir sur les briques, \texttt{AbstractBrick} hérite de
\texttt{Bounceable}. Une brique est définie comme un type de
\texttt{Bounceable} ayant:

\begin{itemize}

    \item Une couleur, directemment liée au nombre de points qu'elle rapporte
        au joueur, une fois que celui-ci la détruit.

    \item Une durabilité, représentant le nombre de coup que celle-ci peut
        encore subir avant d'être détruite.

    \item Le type type de bonus qu'elle contient.

\end{itemize}

Afin d'associer à sa couleur un nombre de points rapportés lors de la
destruction, nous utilisons l'énuméré \texttt{AbstractBrick::Color}. \\

Lorsque la \texttt{GameBoard} détecte qu'une balle rebondit sur la brique, elle
doit signaler à la brique qu'elle a été touchée. Ceci est implémenté via la
méthode \texttt{hit} servant à décrémenter la durabilité et, si celle-ci est
détruite, renvoyer le type de bonus que la brique contenait. \\

Les briques dorées ne pouvant pas être détruites contrairement aux autres, nous
avons créé deux classes héritant de \texttt{brick}:

\begin{itemize}

    \item \texttt{BasicBrick} Pour les briques implémentant les caractérstiques
        d'une brique simple, i.e. qui peut être détruite.

    \item \texttt{GoldBrick} Pour les briques dorées qui ne peuvent pas être détruite.

\end{itemize}

L'interface qu'offrent \texttt{BasicBrick} et \texttt{GoldBrick} est exactement
la même interface que celle de \texttt{AbstractBrick}. Nous implémentons une
"méthode-usine" ("factory") renvoyant un pointeur de brique pouvant pointer
vers une \texttt{BasicBrick} ou une \texttt{GoldBrick}.

\subsubsection{Border}

La classe \texttt{Border} représente les trois bordures du plateau de jeu sur
lesquelles les balles rebondissent (en haut, à gauche et à droite).
\texttt{Border} hérite de \texttt{Bounceable} et n'implémente aucune méthode
particulière. 

\subsubsection{Racket}

La classe \texttt{Racket} représente la raquette. Puisque les balles peuvent rebondir
dessus, celle-ci hérite de \texttt{Bounceable}. \\

Afin de déplacer la raquette lattéralement, la classe \texttt{Racket} possède
le setter \texttt{setCenterX}. \\

La classe \texttt{Racket} modifie l'effet de rebond par défaut de
\texttt{Bounceable} en surchargeant la méthode \texttt{getDirVecAfterBounce}.
Cela permet d'ajouter l'effet de variation de l'angle entre la balle et
l'horizontale en fonction de la distance entre le centre de la raquette et le
point d'impact de la balle.

\subsubsection{Ball}

La classe \texttt{Ball} représente une balle du jeu. Celle-ci possède
essentiellement une position, un rayon, une vitesse et un vecteur directeur.
Nous nous assurons que la balle garde une vitesse de déplacement directement
proportionnelle à son attribut vitesse, en gardant le vecteur directeur
toujours normé, c'est-à-dire que son module vaut 1. Ceci est assuré par la
méthode permettant de changer le vecteur directeur et le constructeur de
\texttt{Ball}. Le scalaire vitesse est donc le seul pouvant influencer la
vitesse de déplacement de la balle. \\

La méthode \texttt{checkCollision} permet de vérifier si la balle est rentrée
en collision avec un \texttt{RectangleShape}. Cette méthode est utilisée par la
\texttt{GameBoard} au moment de trouver les collisions qui ont eu lieu à un
instant $T$. La méthode \texttt{collide} également appelée par
\texttt{GameBoard} permet ensuite de resoudre la collision
(\ref{lexique:resoudre_collisions}) avec un \texttt{RectangleShape}. \\

La méthode \texttt{update} prenant un paramètre représentant une durée $deltaT$
permet de mettre à jour la position de la balle à l'instant $T + deltaT$.

\subsubsection{BonusType}

L'énuméré contient les différents types de bonus implémentés, ainsi que la
valeur \texttt{None}, représentant l'absence de bonus.

\subsubsection{Bonus à durée limitée}

Les bonus à durée limitée sont gérés par les classes \texttt{BasicTimedBonus}
et \texttt{SlowDownBonus}, qui héritent de la classe abstraite
\texttt{AbstractTimedBonus}. Cette dernière fournit une structure commune avec
un attribut \texttt{BonusType} (indiquant le type de bonus) ainsi qu'une
interface pour notifier le bonus de :

\begin{itemize}

    \item L'écoulement d'une durée $deltaT$

    \item Réappliquer le bonus (Ceci est nécessaire uniquement pour les bonus
        "SlowDown" car les effets sont cumulables).

\end{itemize}

La classe \texttt{BasicTimedBonus} hérite de \texttt{AbstractTimedBonus} et
gère le temps d'activité de celui-ci. Elle implémente la méthode
\texttt{update} de l'interface de \texttt{AbstractTimedBonus}, permettant de
diminuer le temps restant du bonus d'une durée donnée. Nous l'utilisons pour
les bonus suivants: "WideRacket", "Lazer" et "StickyRacket". \\

Le bonus "SlowDown" est cumulable, contrairement aux autres. Cela signifie que
si le joueur attrape un "SlowDown" alors qu'un ou plusieurs "SlowDown" étaient
déjà actifs, la balle doit ralentir davantage. La méthode
\texttt{getSlowDownFactor} est spécifique à celui-ci et permet d'obtenir la
valeur par laquelle la vitesse de base de la balle doit être divisée pour
obtenir sa vitesse avec cette configuration de bonus "SlowDown". Cette valeur
est proportionnelle à la somme des temps restants pour tous les "SlowDown"
actifs. \\

Le fait que seul le bonus "SlowDown" soit cumulable contrairement aux autres,
est la raison pour laquelle nous choisissons d'implémenter les bonus à l'aide
de 3 classes dont une classe abstraite permettant d'unifier le comportement
commun des deux autres.

\subsubsection{BonusPill}

La classe \texttt{BonusPill} représente une capsule/pillule de bonus contenant
un \texttt{BonusType}. Celle-ci étant rectangulaire mais ne laissant pas la
balle rebondir dessus, elle hérite seulement de \texttt{RectangleShape}. Elle
possède également une vitesse de descente. La méthode isOverlapping, héritée de
\texttt{RectangleShape} permet de vérifier si la pillule est rentrée en
collision avec un autre \texttt{RectangleShape}. Nous utilisons cette méthode
sur la raquette afin de savoir si la raquette a attrapé la \texttt{BonusPill}.
La méthode \texttt{update} permet de faire descendre le bonus de la distance
qu'il aurait parcouru après un nombre de secondes donné en paramètre.

\subsubsection{ScoreManager}

La classe \texttt{ScoreManager} gère et centralise les informations concernant
le score, c'est-à-dire le meilleur score et le score du joueur à un instant
donné.

\subsubsection{LifeCounter}

La classe \texttt{LifeCounter} s'occupe de gérer le nombre de vies du joueur.
Cependant, c'est la \texttt{GameBoard} qui doit lui notifier les pertes et les
gains de vie. Par exemple, lorsque le joueur n'a plus de balle en jeu,
\texttt{GameBoard} doit envoyer un message au \texttt{LifeCounter} pour que
celui-ci décrémente le nombre de vies.

\subsubsection{Lazer}

La classe \texttt{Lazer} représente un laser tiré vers le haut et provenant de
la raquette. Celui-ci est de forme rectangulaire et ne fait pas rebondir la
balle, il hérite donc uniquement de \texttt{RectangleShape}. Celui-ci possède
une vitesse. Nous utilisons la méthode \texttt{isOlverapping} héritée de
\texttt{RectangleShape} afin de vérifier si le laser a collisionné avec un
autre \texttt{RectangleShape}, plus précisément: une brique. La méthode
\texttt{update} permet de faire monter le bonus de la distance qu'il aurait
parcouru après $deltaT$ secondes.

\subsection{Vue}

Toutes les classes utilisées pour la vue se trouvent dans le dossier
\texttt{src/view}.

\subsubsection{DisplayGame}

La classe \texttt{DisplayGame} gère l'affichage global du jeu. Elle utilise la
classe \texttt{Canvas} pour dessiner les éléments et dépend de
\texttt{GameBoard} pour accéder aux données du jeu. Cette classe utilise des
ressources graphiques Allegro (\texttt{ALLEGRO\_DISPLAY},
\texttt{ALLEGRO\_BITMAP}) et des polices (\texttt{ALLEGRO\_FONT}). Mais
d'abord, elle  initialise Allegro et vérifie les erreurs d'initialisation.

\subsubsection{Canvas}

La classe \texttt{Canvas} permet d'afficher tous les éléments du jeu. Celle-ci
utilise les getters de \texttt{GameBoard} pour accéder aux entités de la partie
modèle, e.g. la raquette, les balles, les briques. 

Afin de diminuer le couplage entre la vue et le modèle, notre affichage est
découpé en 2 étapes se répétant pour chaque élément du jeu à afficher:

\begin{enumerate}

    \item \textbf{Traduction} : Le \texttt{Canvas} construit l'élément servant
        à l'affichage correspondant à l'entité de la \texttt{GameBoard} à
        afficher. Par exemple, pour afficher la raquette, nous construisons
        l'objet \texttt{RacketUi} sur base de la \texttt{Racket} du
        \texttt{GameBoard}.

    \item \textbf{Affichage} : Le \texttt{Canvas} appelle la méthode
        \texttt{draw} de l'élément à dessiner pour afficher celui-ci.

\end{enumerate}

\subsubsection{Formes Géométriques}
\begin{itemize}

    \item \textbf{Circle} : Classe de base pour les objets de forme circulaire,
        e.g. \texttt{BallUi}.

    \item \textbf{Rectangle} : Classe de base pour les objets rectangulaires,
        e.g. \texttt{WallUi}, \texttt{RacketUi}.

    \item \textbf{Responsabilités} :

    \begin{itemize}

        \item Gérer les attributs géométriques (position, dimensions,
            couleurs).

        \item Fournir une méthode \texttt{draw()} pour dessiner la forme.

    \end{itemize}

\end{itemize}

\subsubsection{Autres Classes}
\begin{itemize}

    \item \textbf{WallUi} : Représente les murs dans l'interface utilisateur,
        hérite de \texttt{Rectangle}.

    \item \textbf{RacketUi} : Représente la raquette du joueur, hérite de
        \texttt{Rectangle}.

    \item \textbf{LazerUi} : Représente les lasers, hérite de
        \texttt{Rectangle}.

    \item \textbf{BrickUi} : Gère l'affichage des briques, hérite de
        \texttt{Rectangle} et travaille avec \texttt{AbstractBrick}.

    \item \textbf{BonusPillUi} : Affiche les bonus tombants, hérite de
        \texttt{Rectangle}.

    \item \textbf{BallUi} : Représente les balles dans le jeu, hérite de
        \texttt{Circle}.

\end{itemize}

\subsection{Contrôleur}

Toutes les classes utilisées pour le contrôleur se trouvent dans le dossier
\texttt{src/controller}. \\

La classe \texttt{ControllerGame} gère la logique principale du jeu, y compris
les événements, la progression des niveaux et l'interaction entre les éléments
du jeu. Celle-ci dépend de \texttt{GameBoard} pour toute la logique du jeu, et
interagit avec \texttt{DisplayGame} pour l'affichage. Elle utilise également
\texttt{LevelManager} pour gérer les niveaux et charger leurs données. \\

\texttt{ControllerGame} est responsable de :

\begin{itemize}

    \item Gérer la boucle principale du jeu.

    \item Gérer les événements d'entrée comme le clavier.

    \item Charger les niveaux via le \texttt{LevelManager}.

    \item Contrôler les transitions de victoire et de défaite.

    \item Interagir avec Allegro pour la gestion des événements du timer et de
        l'affichage.

    \item Demander à \texttt{DisplayGame} d'afficher l'état du jeu en cours
        lorsque nécessaire.

\end{itemize}


\subsection{Log}

Les fichiers de la classe \texttt{Log} se trouvent dans le dossier
\texttt{src/log}. \\

Dans l'optique de faciliter le débogage, essentiellement pour les collisions,
nous ajoutons le singleton \texttt{Log}, qui permet d'enregistrer des
évènements classés par catégories lors de l'éxécution. Nous pouvons
activer/désactiver des catégories et ajouter des évènements dans des
catégories. Toutefois, cela nécessite de modifier le code source et de
recompiler.

\section{Logique du jeu}

Dans cette section, nous détaillons le fonctionnement du programme entre son
lancement et la première fois que la balle collisionne avec une brique. \\

Au lancement du jeu, le programme commence par initialiser les différentes
classes nécessaires : En premier lieu, nous instancions un objet
\texttt{ControllerGame}. Celui-ci permet de contrôler le plateau de jeu et la
vue. Lors de sa création, \texttt{ControllerGame} crée l'objet
\texttt{GameBoard} dans un \texttt{shared\_ptr} représentant le plateau de jeu,
la partie "modèle". Il construit également un objet \texttt{LevelManager}. Ce
dernier permet de charger tous les différents niveaux en une fois, avec les
murs, la raquette et les briques. \\

Afin de préparer la \texttt{GameBoard} pour le niveau choisi, le
\texttt{ControllerGame} passe une copie de tous les éléments du jeu obtenus par
les getters du \texttt{LevelManager} à la \texttt{GameBoard} à l'aide des
setters. Ensuite, il crée aussi l'objet \texttt{DisplayGame} en lui passant le
\texttt{shared\_ptr} pointant ver la \texttt{GameBoard} afin que celui-ci
affiche le jeu. Lors de sa construction, \texttt{DisplayGame} initialise
\texttt{Allegro} pour pouvoir afficher une fenêtre. À chaque fois que nous
avons besoin d'afficher l'état du jeu, \texttt{DisplayGame} demande à
\texttt{GameBoard} l'état du plateau de jeu pour l'afficher. \\

Une fois que ces différents objets sont créés, le programme installe le
nécessaire pour pouvoir utiliser le clavier et la souris dans le jeu. Puis,
\texttt{ControllerGame} initialise le \texttt{ALLEGRO\_TIMER} qui permet
d'avoir un "tick" à une fréquence donnée. Nous utilisons celui-ci afin de
mettre à jour \texttt{GameBoard} ainsi que pour afficher l'état du jeu à
l'écran. Nous séparons la vitesse de mise à jour de \texttt{GameBoard} du
nombre d'images affichées par Allegro à chaque seconde afin d'obtenir de
meilleurs performances. Le plateau de jeu est mise à jour 500 fois par seconde
tandis qu'Allegro affichera une image à l'écran 125 fois par seconde. \\

Ensuite, le \texttt{ControllerGame} démarre le \texttt{ALLEGRO\_TIMER}. A
chaque "tick" du timer, le \texttt{ControllerGame} récupère la position de la
souris, notifie la \texttt{GameBoard} de la nouvelle position de la raquette
(en fonction de la position de la souris), et demande à la \texttt{GameBoard}
de se mettre à jour. A chaque mis à jour, la \texttt{GameBoard} met à jour tous
ses composants et vérifie si la balle est entrée en collision avec un ou
plusieurs objets. Si c'est le cas, elle résout les collisions
(\ref{lexique:resoudre_collisions}), ajuste le score et fait apparaitre les
pillules de bonus si nécessaire en les ajouttant au vecteur prévu à cet effet.
Pour les briques, elle signale également à la brique que celle-ci est touchée.
Si la durabilité de la brique est 0, \texttt{GameBoard} supprime celle-ci de
son vecteur de briques. Pour les pillules de bonus et les lasers, il n'y pas de
collision à résoudre: \texttt{GameBoard} applique l'effet correspondant (i.e.
destruction de brique, enregistrer le bonus comme bonus actif) et supprime
simplement l'objet du vecteur correspondant. \\

A chaque mise-a-jour, le \texttt{GameBoard} vérifie s'il y a encore au moins
une balle en jeu. Si ce n'est pas le cas, il retire une vie. Le
\texttt{ControllerGame} demande à \texttt{GameBoard} le nombre de vies et de
briques non-dorées restantes. S'il n'y a plus de briques non-dorées, le joueur
a gagné. S'il ne reste aucune vie, le joueur a perdu. Ensuite si un de ces deux
évènements survient, le controleur demande l'affichage de l'écran de fin
approprié (victoire ou défaite).  \\

Si des événements arrivent dans la \textit{queue} d'Allegro, ils seront traités
avant d'afficher le jeu à l'écran. \\

\section{Modèle-Vue-Contrôleur}

Notre imlémentation suivant les principes de l'architecture
\texttt{'Modèle-Vue-Contrôleur'} implique que notre programme soit divisé en
trois parties distinctes : 

\begin{itemize}

    \item \texttt{Modèle}

    \item \texttt{Vue}

    \item \texttt{Contrôleur}

\end{itemize}

\subsection{Modèle}

Cette partie contient toute la logique pour le plateau du jeu. Elle permet
d'avoir l'état du plateau de jeu et de le modifier. Celle-ci est donc
indépendante des composants servant pour la partie Vue et Contrôleur. La classe
\texttt{GameBoard} représente l'état du jeu et possède une méthode pour pouvoir
être mise à jour. C'est à l'aide de cette méthode que le contrôleur intéragit
avec \texttt{GameBoard}.

\subsection{Vue}

La partie vue permet seulement d'afficher l'état du plateau de jeu à un moment
donné. La vue demande au modèle son état pour l'afficher à l'écran, à l'aide de
la bibliothèque Allegro. 

\subsection{Contrôleur}

Cette troisième partie permet de contrôler le modèle et de notifier la vue
lorsqu'il est nécessaire d'afficher l'état du jeu. Grâce à ce celui-ci, nous
pouvons gérer le modèle et la vue indépendamment. Le contrôleur possède un
\texttt{shared\_ptr} vers l'objet \textit{GameBoard} pour lui demander de se
mettre à jour, et un \textit{DisplayGame} pour lui demander d'afficher l'état
du jeu.


\section{Conclusion}

Pour conclure ce rapport, nous dirons que ce projet nous a permis de développer
nos compétences en programmation orientée objet grâce au développement d'une
version fonctionnelle du jeu \texttt{Arkanoid}. Le respect de l'architecture
\texttt{Modèle-Vue-Contrôleur} a été essentielle pour nous répartir les tâches
entre nous, et pour structurer notre code et garantir une séparation claire des
responsabilités entre la logique du jeu, l’affichage du jeu, et le contrôle des
événements. \\

Le fait que ce projet soit un jeu avec une interface graphique nous a également
permis de prendre du plaisir à le réaliser tout en approfondissant notre
connaissance du langage \texttt{C++}. \\

Cette expérience nous a non seulement permis de développer un programme abouti,
mais également d’affiner nos compétences en conception, en programmation et en
travail d'équipe.

\section{Interfaces des classes}

% ControllerGame

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    ControllerGame();

    virtual ~ControllerGame();

    void process();
\end{lstlisting}
  \caption{Interface de ControllerGame}
\end{figure}

% LevelManager

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    LevelManager();

    virtual ~LevelManager();

    void nextLevel();

    void previousLevel();

    const vector<shared_ptr<AbstractBrick>> &getBricks();

    const shared_ptr<Racket> getRacket() const;

    const vector<shared_ptr<Border>> &getBorders() const;
\end{lstlisting}
  \caption{Interface de LevelManager}
\end{figure}

% Ball

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    Ball(const Vec2 &center, Vec2 directionVec, double radius = BALL_RADIUS,
         double speed = BALL_SPEED, isStuck = false);

    Ball(const Ball &other);

    Ball(Ball &&);

    Ball &operator=(const Ball &);

    Ball &operator=(Ball &&);

    virtual ~Ball();

    double getRadius() const noexcept;

    const Vec2 &getCenter() const noexcept;

    const Vec2 &getDirvec() const noexcept;

    bool isStuck() const noexcept;

    void setSpeed(double speed);

    void setIsStuck(bool isStuck);
    
    void setCenter(const Vec2 &center);
    
    void setCenterX(double centerX);

    void setSpeed(unsigned speed);

    void setDirVec(const Vec2 &vec);

    Vec2 getSimplePenetrationVec(const RectangleShape &rectangleShape) const;

    bool checkCollision(const RectangleShape &rectangleShape) const;

    void collide(const Bounceable &bounceable);

    void update(double deltaTime);
\end{lstlisting}
  \caption{Interface de Ball}
\end{figure}

% AbstractTimedBonus

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    virtual ~AbstractTimedBonus();

    BonusType getBonusType() const;

    virtual bool update(double deltaT) = 0;

    virtual void reapply(){};
\end{lstlisting}
  \caption{Interface de AbstractTimedBonus}
\end{figure}

% BasicTimedBonus

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    BasicTimedBonus(BonusType bonusType);

    BasicTimedBonus(const BasicTimedBonus &);

    BasicTimedBonus(BasicTimedBonus &&);

    BasicTimedBonus &operator=(const BasicTimedBonus &);

    BasicTimedBonus &operator=(BasicTimedBonus &&);

    virtual ~BasicTimedBonus();

    virtual bool update(double deltaT);
\end{lstlisting}
  \caption{Interface de BasicTimedBonus}
\end{figure}

% SlowDownBonus

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    SlowDownBonus();

    SlowDownBonus(const SlowDownBonus &);

    SlowDownBonus(SlowDownBonus &&);

    SlowDownBonus &operator=(const SlowDownBonus &);

    SlowDownBonus &operator=(SlowDownBonus &&);

    virtual ~SlowDownBonus();

    virtual void reapply() override;

    virtual bool update(double deltaT) override;

    virtual double getSlowDownFactor() const;
\end{lstlisting}
  \caption{Interface de SlowDownBonus}
\end{figure}

% BonusPill

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    BonusPill(const Vec2 &center, BonusType bonusType);

    BonusPill(const BonusPill &);

    BonusPill(BonusPill &&);

    BonusPill &operator=(const BonusPill &);

    BonusPill &operator=(BonusPill &&);

    BonusType getBonusType() const;

    void update(double deltaTime);
\end{lstlisting}
  \caption{Interface de BonusPill}
\end{figure}

% BonusType

\begin{figure}[ht]
  \centering
\begin{lstlisting}
enum class BonusType {
    None,
    SlowDown,
    ExtraLife,
    WideRacket,
    SplitBall,
    Lazer
};
\end{lstlisting}
  \caption{Enuméré BonusType}
\end{figure}

% Border

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    Border(const Vec2 &center, double width, double height);

    Border(const Vec2 &topLeft, const Vec2 &bottomRight);

    Border(const Border &other);

    Border(Border &&);

    Border &operator=(const Border &);

    Border &operator=(Border &&);

    virtual ~Border();
\end{lstlisting}
  \caption{Interface de Border}
\end{figure}

% Bounceable

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    enum class BounceType { Vertical, Horizontal, Corner };

    virtual ~Bounceable();

    virtual Vec2 getDirVecAfterBounce(const Vec2 &closestPoint,
                                      const Vec2 &dirVec) const;

    virtual BounceType getBounceType(const Vec2 &point) const final;

    static std::string bounceTypeToString(BounceType bounceType);
\end{lstlisting}
  \caption{Interface de Bounceable}
\end{figure}

% AbstractBrick

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    enum class Color : size_t {
        defaultBrick = 1,
        white = 50,
        orange = 60,
        cyan = 70,
        green = 80,
        red = 90,
        blue = 100,
        magenta = 110,
        yellow = 120,
        silver = 200,
        gold = 0,
    };

    virtual ~AbstractBrick();

    static std::unique_ptr<AbstractBrick>
    makeBrick(const Vec2 &center, double width, double height, Color color,
              BonusType bonusType = BonusType::None);

    virtual BonusType hit();

    virtual Color getColor() const;

    virtual size_t getScore() const;

    virtual uint8_t getDurability() const;

    virtual bool isDestroyed() const;

    virtual BonusType getBonusType() const;

    virtual bool hasBonus() const;

    virtual std::shared_ptr<AbstractBrick> clone() = 0;
\end{lstlisting}
  \caption{Interface de AbstractBrick}
\end{figure}

% BasicBrick

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    BasicBrick(const Vec2 &center, double width, double height, Color color,
               uint8_t durability, BonusType bonusType = BonusType::None);

    virtual ~BasicBrick();

    virtual std::shared_ptr<AbstractBrick> clone() override;
\end{lstlisting}
  \caption{Interface de BasicBrick}
\end{figure}

% GoldBrick

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    GoldBrick(const Vec2 &center, double width, double height);

    virtual ~GoldBrick();

    virtual BonusType hit() override;

    virtual std::shared_ptr<AbstractBrick> clone() override;
\end{lstlisting}
  \caption{Interface de GoldBrick}
\end{figure}

% GameBoard

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    GameBoard();

    virtual ~GameBoard();

    void update(double deltaTime);

    void shootLazerOrReleaseBall();

    unsigned long getScore() const;

    const LifeCounter &getLife() const;

    unsigned long getNumBricks() const;

    const std::vector<std::shared_ptr<Ball>> &getBalls() const;

    const std::vector<std::shared_ptr<AbstractBrick>> &getBricks() const;

    const std::vector<std::shared_ptr<BonusPill>> &getDescendingBonuses() const;

    const Racket &getRacket() const;

    const std::vector<std::shared_ptr<Border>> &getBorders() const;

    const std::vector<std::shared_ptr<Lazer>> &getLazers() const;

    void setRacketAtX(double centerX);

    void setBricks(const std::vector<std::shared_ptr<AbstractBrick>> &bricks);

    void setRacket(const std::shared_ptr<Racket> racket);

    void setBorders(const std::vector<std::shared_ptr<Border>> &borders);

    void resetLifeCounter();

    void resetScore();

    void saveBestScore();

    unsigned long getBestScore() const;

    void resetBestScore();

    void clear();
\end{lstlisting}
  \caption{Interface de GameBoard}
\end{figure}

% Lazer

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    Lazer(const Vec2 &center);

    Lazer(const Lazer &);

    Lazer(Lazer &&);

    Lazer &operator=(const Lazer &);

    Lazer &operator=(Lazer &&);

    void update(double deltaTime);
\end{lstlisting}
  \caption{Interface de Lazer}
\end{figure}

% LifeCounter

\begin{figure}[ht]
  \centering
\begin{lstlisting}

    LifeCounter();

    LifeCounter(const LifeCounter &);

    LifeCounter(LifeCounter &&);

    LifeCounter &operator=(const LifeCounter &);

    LifeCounter &operator=(LifeCounter &&);

    LifeCounter(unsigned numLives);

    virtual ~LifeCounter();

    void reset();

    const LifeCounter &operator--();

    const LifeCounter &operator++();

    const LifeCounter &operator+=(unsigned numLife);

    void setNumLives(uint8_t numLives);

    operator unsigned() const;
\end{lstlisting}
  \caption{Interface de LifeCounter}
\end{figure}

% Racket

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    Racket(const Vec2 &center, double width, double height);

    Racket(const Racket &other);

    Racket(Racket &&);

    Racket &operator=(const Racket &);

    Racket &operator=(Racket &&);

    virtual ~Racket();

    void setCenterX(double centerX);

    Vec2 getDirVecAfterBounce(const Vec2 &closestPoint,
                              const Vec2 &dirVec) const override;
\end{lstlisting}
  \caption{Interface de Racket}
\end{figure}

% RectangleShape

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    RectangleShape(const Vec2 &center, double width, double height);

    RectangleShape(const Vec2 &topLeft, const Vec2 &bottomRight);

    RectangleShape(const RectangleShape &other);

    RectangleShape(RectangleShape &&);

    RectangleShape &operator=(const RectangleShape &);

    RectangleShape &operator=(RectangleShape &&);

    virtual ~RectangleShape();

    void setCenter(const Vec2 &centerPos);

    void setWidth(double newWidth);

    void setHeight(double newWidth);

    const Vec2 &getCenter() const noexcept;

    double getWidth() const noexcept;

    double getHeight() const noexcept;

    double getLeft() const noexcept;

    double getRight() const noexcept;

    double getBottom() const noexcept;

    double getTop() const noexcept;

    Vec2 getTopLeft() const noexcept;

    Vec2 getTopRight() const noexcept;

    Vec2 getBottomLeft() const noexcept;

    Vec2 getBottomRight() const noexcept;

    bool isOverlapping(const RectangleShape &other);
\end{lstlisting}
  \caption{Interface de RectangleShape}
\end{figure}

% ScoreManager

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    ScoreManager();

    ScoreManager(const ScoreManager &);

    ScoreManager(ScoreManager &&);

    ScoreManager &operator=(const ScoreManager &);

    ScoreManager &operator=(ScoreManager &&);

    ScoreManager(unsigned long currentScore, unsigned long bestScore)
        : currentScore_(currentScore), bestScore_(bestScore) {}

    virtual ~ScoreManager();

    void increaseScore(unsigned long value);

    void resetScore();

    void saveScore();

    unsigned long getCurrentScore() const;

    unsigned long getBestScore() const;

    void resetBestScore();
\end{lstlisting}
  \caption{Interface de ScoreManager}
\end{figure}

% Vec2

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    double x;
    double y;

    Vec2();

    Vec2(double xComponent, double yComponent);

    Vec2(const Vec2 &);

    Vec2(Vec2 &&);

    Vec2 &operator=(const Vec2 &);

    Vec2 &operator=(Vec2 &&);

    virtual ~Vec2();

    double getModule() const;

    const Vec2 &normalize();

    Vec2 normalized() const;

    Vec2 clamped(const Vec2 &min, const Vec2 &max) const;

    bool operator==(const Vec2 &other) const;

    Vec2 operator+(const Vec2 &vec) const;

    Vec2 &operator+=(const Vec2 &vec);

    Vec2 operator-(const Vec2 &vec) const;

    Vec2 &operator-=(const Vec2 &vec);

    Vec2 operator-() const;

    Vec2 operator*(double scalar) const;

    Vec2 &operator*=(double scalar);

    operator Point() const;

    operator std::string() const;
\end{lstlisting}
  \caption{Interface de Vec2}
\end{figure}

% Canvas

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    Canvas(shared_ptr<GameBoard> gameBoard, ALLEGRO_FONT *fontBrick);

    virtual ~Canvas();

    void draw();
\end{lstlisting}
  \caption{Interface de Canvas}
\end{figure}

% DisplayGame

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    DisplayGame(shared_ptr<GameBoard> gameBoard);

    virtual ~DisplayGame();

    void draw();

    void gameOver();

    void gameWin();

    ALLEGRO_DISPLAY *getDisplay() const;
\end{lstlisting}
  \caption{Interface de DisplayGame}
\end{figure}

% Rectangle

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    Rectangle(Point center, float width, float height,
              ALLEGRO_COLOR fillColor = COLOR_BLACK,
              ALLEGRO_COLOR frameColor = COLOR_WHITE);

    virtual ~Rectangle();

    virtual void draw();
\end{lstlisting}
  \caption{Interface de Rectangel}
\end{figure}

% Circle

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    Circle(Point center, float radius, ALLEGRO_COLOR fillColor = COLOR_WHITE,
           ALLEGRO_COLOR frameColor = COLOR_BLACK);

    virtual ~Circle();

    virtual void draw();
\end{lstlisting}
  \caption{Interface de Circle}
\end{figure}

% Point

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    float x = 0, y = 0; // Coordinates of the point

    Point(float valX, float valY);

    virtual ~Point();
\end{lstlisting}
  \caption{Interface de Point}
\end{figure}

% BallUi

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    BallUi(Point center, float radius, ALLEGRO_COLOR color = COLOR_BLUE);

    virtual ~BallUi();

    virtual void draw() override;
\end{lstlisting}
  \caption{Interface de BallUi}
\end{figure}


% BonusPillUi

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    BonusPillUi(Point center, float width, float height, BonusType bonusType);

    virtual ~BonusPillUi();

    virtual void draw() override;

\end{lstlisting}
  \caption{Interface de BonusPillUi}
\end{figure}


% BrickUi

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    BrickUi(Point center, float width, float height, ALLEGRO_COLOR color,
            size_t durability, BonusType bonusType,
            const ALLEGRO_FONT *fontBrick);

    virtual ~BrickUi();

    virtual void draw() override;
\end{lstlisting}
  \caption{Interface de BrickUi}
\end{figure}


% LazerUi

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    LazerUi(Point center, float width, float height, ALLEGRO_COLOR = COLOR_RED);

    virtual ~LazerUi();

    virtual void draw() override;
\end{lstlisting}
  \caption{Interface de LazerUi}
\end{figure}

% RacketUi

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    RacketUi(Point center, float width, float height,
             ALLEGRO_COLOR = COLOR_WHITE);

    virtual ~RacketUi();

    virtual void draw() override;
\end{lstlisting}
  \caption{Interface de RacketUi}
\end{figure}

% WallUi

\begin{figure}[ht]
  \centering
\begin{lstlisting}
    WallUi(Point center, float width, float height,
           ALLEGRO_COLOR = COLOR_WHITE);

    virtual ~WallUi();

    virtual void draw() override;
\end{lstlisting}
  \caption{Interface de WallUi}
\end{figure}

\clearpage

\section*{Lexique}


\begin{description}

\item[Résoudre les collisions] \label{lexique:resoudre_collisions} Dû à notre
    approche pour la physique du jeu dite "discrète"
    (\ref{lexique:physique_discrete}), certains objets se retrouvent en
    superposition au lieu de collisionner (et rebondir). Résoudre les
    collisions consiste à replacer les objets à l'endroit où ils étaient juste
    avant la collision, et appliquer l'effet de rebond si nécessaire.

\item[Physique discrète] \label{lexique:physique_discrete} Simulation où le
    temps avance par étapes, ce qui peut parfois entraîner des imprécisions ou
    des chevauchements entre objets.

\end{description}


\end{document}

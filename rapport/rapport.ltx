\documentclass{article}
\usepackage[margin=3.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{titling} % Pour personnaliser l'emplacement des éléments liés au titre
\usepackage[T1]{fontenc}
\usepackage{enumitem}
\usepackage{hyperref}

\title{Rapport sur le projet de Langage de Programmation : Arkanoïd}
\date{5 janvier 2025}


%TODO: \textit -> \texttt
%TODO: plateau de jeu -> grille de jeu

\begin{document}

\maketitle
\vspace{-1cm} % Réduire l'espace entre le titre et le tableau
\begin{table}[h!]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Prénom & Nom & Matricule \\ \hline
        Lucas  & Verbeiren & 000591223 \\ \hline
        Ethan  & Van Ruyskensvelde & 000589640 \\ \hline
    \end{tabular}
    \label{tab:my_label}
\end{table}

\tableofcontents % Table des matières

\newpage

\section{Introduction}

Dans le cadre de ce projet, nous avons dû réaliser une version fonctionnelle
avec une interface graphique du célèbre jeu \texttt{Arkanoid} en utilisant les
principes de la programmation orientée objet. \\

Le développement a été réalisé en \texttt{C++} avec l'utilisation de la
bibliothèque \texttt{Allegro} pour l'interface graphique. Le projet a été
réalisé à l'aide du \texttt{Modèle-Vue-Contrôleur} (MVC) afin de séparer
clairement les différentes responsabilités du code. \\

L’objectif principal est d’implémenter un niveau fonctionnel avec les
différentes mécaniques de jeu :

\begin{itemize}

    \item Déplacement de la raquette,

    \item Rebonds de la balle,

    \item Gestion des briques,

    \item Gestion des vies,

    \item Gestion du score,

    \item Niveaux multiples,

    \item Briques colorées,

    \item Bonus.

\end{itemize}

Enfin, ce projet vise également à montrer notre compréhension des concepts
principaux de la programmation orientée objet et notre capacité à structurer un
projet complet. À travers cette réalisation, nous cherchons à fournir un
programme robuste, modulaire et bien documenté.

\section{Tâches accomplies}

Pour ce projet, nous avons réalisé toutes les tâches de base, c'est-à-dire :

\begin{itemize}

    \item Rebond correct de la balle sur les différentes surfaces comme les
        briques, les murs et la raquette,

    \item Déplacement de la raquette,

    \item Un niveau comportant 8 lignes de 14 briques,

    \item Un affichage du score qui est mit à jour en gagnant 1 point par
        brique cassée. Si le joueur a cassé toutes les briques, un message de
        victoire est affiché,

    \item Un système de vie où le joueur a 3 vies maximum par partie. S'il les
        perd toutes, un message de défaite est affiché.

\end{itemize}

Nous avons également effectué ces différentes tâches additionnelles :

\begin{itemize}

    \item Un système de niveau où chaque niveau est encodé dans un fichier
        '.txt', avec la possibilité d'encoder un bonus pour une brique,

    \item Déplacement de la raquette avec la souris,

    \item Des briques avec différentes couleurs et où chaque couleur fait
        remporté des points différents. De plus, nous sauvegardons après chaque
        partie le meilleur score dans un fichier 'score.txt' et le meilleur
        score est affiché en cours de partie. Nous avons également implémenté
        une touche qui permet de réinitialiser le meilleur score,

    \item L'ajout de briques argentées et dorées. Une brique dorée ne peut
        jamais être cassée et une brique argentée a besoin d'être touché deux
        fois par la balle pour pouvoir être cassée, 

    \item Le bonus qui permet d'agrandir la raquette lorsque le joueur attrape
        la capsule bleue,

    \item Le bonus qui permet de ralentir la vitesse de la balle lorsque le
        joueur attrape la capsule orange,

    \item Le bonus qui permet de gagner une vie en attrapant la capsule grise,

    \item Le bonus qui permet de tirer un laser en attrapant la capsule
        magenta,

    \item Le bonus qui permet de diviser la balle en trois instances d'elle
        même si le joueur attrape la capsule cyan.

\end{itemize}



\section{Interface des différentes classes, leurs rôles et liens avec les
autres classes}

% TODO: Log

\subsection{Modèle}
\subsubsection{GameBoard}

La classe GameBoard est l'élément central du modèle. Elle coordonne et fait
évoluer les autres composants du modèle au fil du temps. Le tableau
\ref{tab:responsabilites} détaille ces composants ainsi que les classes
associées à chacun :

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Composant du modèle}        & \textbf{Classe}   \\ \hline
        Le score                            & ScoreManager      \\ \hline
        Le compteur de vie                  & LifeCounter       \\ \hline
        Le bonus actif                      & Bonus             \\ \hline
        Les capsules de bonus qui tombent   & BonusPill         \\ \hline
        Les lazers                          & Lazer             \\ \hline
        La raquette                         & Racket            \\ \hline
        Les bordures du plateau de jeu      & Border            \\ \hline
        Les briques                         & Brick             \\ \hline
        Les balles                          & Ball              \\ \hline
    \end{tabular}
    \caption{Correspondance entre les composants du modèle et les classes.}
    \label{tab:responsabilites}
\end{table}

Le contrôleur qui possède l'horloge du jeu doit pouvoir signaler à la GameBoard
de mettre à jour les composants du modèle et combien de temps s'est écoulé
entre cette mise à jour et la précédente. Cela est implémenté via la méthode
\texttt{update}. Chaque fois que celle-ci est appelée à un instant $T$, avec un
paramètre $deltaT$, \texttt{GameBoard} met à jour tous les composants du modèle
à l'état correspondant à l'instant \(T + deltaT\).

\subsubsection{Vec2}

La classe \texttt{Vec2} représente un vecteur à deux dimensions. Celle-ci
implémente les opérateurs usuels des vecteurs, e.g. l'addition, la soustraction.

\subsubsection{RectangleShape}

La classe \texttt{RectangleShape} est utilisée pour représenter n'importe quel
objet rectangulaire, tel qu'une brique ou la raquette.

Son interface permet de :
\begin{itemize}

    \item Modifier le centre, la hauteur et la largeur du rectangle.

    \item Obtenir différentes informations sur le rectangle, e.g. la largeur,
        le centre.

    \item Vérifier si une superposition a lieu avec un autre rectangle.

\end{itemize}

\subsubsection{Bounceable}

La classe \texttt{Bounceable} représente un objet rectangulaire sur lequel la
balle peut rebondir. Puisque toutes les instances de cette classes sont
rectangulaires, celle-ci hérite de \texttt{RectangularShape}. 

Par défaut, l'effet de rebond des \texttt{Bounceable}'s consiste simplement à
inverser l'axe $x$ et/ou $y$ du vecteur directeur de la balle en fonction du
type de rebond (rebond sur un coin, une surface verticale ou horizontale). Le
type de rebond s'obtient via la méthode \texttt{getBounceType} renvoyant un
enuméré \texttt{BounceType} représentant ces trois types de rebond. Cependant,
chaque \texttt{Bounceable}'s peut modifier l'effet de rebond par défaut, qui
est donné à tous les \texttt{Bounceable}'s, et ce en "overridant" la méthode
\texttt{getDirVecAfterBounce}.

\subsubsection{Briques}

La classe abstraite \texttt{AbstractBrick} représente une brique. Puisque la
balle peut rebondir sur les briques, \texttt{AbstractBrick} hérite de
\texttt{Bounceable}. Une brique est définie comme un type de
\texttt{Bounceable} ayant:

\begin{itemize}

    \item Une couleur, directemment liée au nombre de points qu'elle rapporte
        au joueur, une fois que celui-ci la détruit.

    \item Une durabilité, représentant le nombre de coup que celle-ci peut
        encore subir avant d'être détruite.

    \item Le type type de bonus qu'elle contient.

\end{itemize}

Afin d'associer à sa couleur un nombre de points rapportés lors de la
destruction, nous utilisons l'énuméré \texttt{AbstractBrick::Color}. \\

Lorsque la \texttt{GameBoard} détecte qu'une balle rebondit sur la brique, elle
doit signaler à la brique qu'elle a été touchée. Ceci est implémenté via la
méthode \texttt{hit} servant à décrémenter la durabilité et, si celle-ci est
détruite, renvoyer le type de bonus que la brique contenait.

Les briques dorées ne pouvant pas être détruites contrairement aux autres, nous
avons créé deux classes héritant de \texttt{brick}:

\begin{itemize}

    \item \texttt{BasicBrick} Pour les briques implémentant les caractérstiques
        d'une brique simple, i.e. qui peut être détruite.

    \item \texttt{GoldBrick} Pour les briques dorées qui ne peuvent pas être détruite.

\end{itemize}

L'interface qu'offrent \texttt{BasicBrick} et \texttt{GoldBrick} est exactement
la même interface que celle de \texttt{AbstractBrick}. Afin de pouvoir profiter du
polymorphisme, nous implémentons une "méthode-usine" ("factory") renvoyant un
pointeur de brique pouvant pointer vers une \texttt{BasicBrick} ou une
\texttt{GoldBrick}.

\subsubsection{Border}

La classe \texttt{Border} représente les trois bordures du plateau de jeu sur
lesquelles les balles rebondissent (en haut, à gauche et à droite).
\texttt{Border} hérite de \texttt{Bounceable} et n'implémente aucune méthode
particulière. 

\subsubsection{Racket}

La classe \texttt{Racket} représente la raquette. Puisque les balles peuvent rebondir
dessus, celle-ci hérite de \texttt{Bounceable}.

Puisque dans le jeu, la raquette doit être déplacée uniquement latéralement,
nous fournissons le setter \texttt{setCenterX}, spécifiquement dédié à cela.

La classe \texttt{Racket} modifie l'effet de rebond par défaut de
\texttt{Bounceable} en surchargeant la méthode \texttt{getDirVecAfterBounce}.
Cela permet d'ajouter l'effet de variation de l'angle entre la balle et
l'horizontale en fonction de la distance par rapport au centre de la raquette.

\subsubsection{Ball}

La classe \texttt{Ball} représente une balle du jeu. Celle-ci possède
essentiellement une position, un rayon, et une vitesse, un vecteur directeur.
Nous nous assurons que la balle garde une vitesse de déplacement directement
proportionnelle à son attribut vitesse, en gardant le vecteur directeur toujours
normalisé, c'est-à-dire que son module vaut 1. Le scalaire vitesse est donc le
seul pouvant influencer la vitesse de déplacement de la balle.

La méthode \texttt{checkCollision} permet de vérifier si la balle est rentrée
en collision avec un \texttt{RectangleShape}. Cette méthode est utilisée par la
\texttt{GameBoard} au moment de trouver les collisions qui ont eu lieu à un
instant $T$. La méthode \texttt{collide} également appelée par
\texttt{GameBoard} permet ensuite de resoudre la collision
(\ref{lexique:resoudre_collisions}) avec un \texttt{RectangleShape}.

La méthode \texttt{update} prenant un paramètre représentant une durée
$deltaTime$ permet de mettre à jour la position de la balle à l'instant $T +
deltaTime$.

\subsubsection{BonusType}

L'énuméré contient les différents types de bonus implémentés, ainsi que la
valeur \texttt{None}, représentant l'absence de bonus.

\subsubsection{Bonus à durée limitée}

Les bonus à durée limitée sont gérés par les classes \texttt{BasicTimedBonus}
et \texttt{SlowDownBonus}, qui héritent de la classe abstraite
\texttt{AbstractTimedBonus}. Cette dernière fournit une structure commune avec
un attribut \texttt{BonusType} (indiquant le type de bonus) ainsi qu'une
interface pour notifier le bonus de :

\begin{itemize}

    \item L'écoulement d'une durée \texttt{deltaT}

    \item Réappliquer le bonus (Ceci est nécessaire uniquement pour les bonus
        "SlowDown" car les effets sont cumulables).

\end{itemize}

La classe \texttt{BasicTimedBonus} hérite de \texttt{AbstractTimedBonus} et
gère le temps d'activité de celui-ci. Elle implémente la méthode
\texttt{update} de l'interface de \texttt{AbstractTimedBonus}, permettant de
diminuer le temps restant du bonus d'une durée donnée. Nous l'utilisons pour
les bonus suivants: "WideRacket" et "Lazer". Nous avions l'intention de
l'utiliser également pour le bonus "Attraper" mais nous ne sommes pas
parvenus à implémenter celui-ci dans les délais du projet. \\

Le bonus "SlowDown" est cumulable, contrairement aux autres. Cela signifie que
si le joueur attrape un "SlowDown" alors qu'un ou plusieurs "SlowDown" étaient
déjà actifs, la balle doit encore plus ralentir.
La méthode \texttt{getSlowDownFactor} est spécifique à celui-ci et permet d'obtenir la
valeur par laquelle la vitesse de base de la balle doit être divisée pour
obtenir sa vitesse avec cette configuration de bonus "SlowDown". Cette valeur
est proportionnelle à la somme des temps restants pour tous les "SlowDown"
actifs.

Le fait qu'il soit cumulable contrairement aux autres bonus, est la raison pour
laquelle nous choisissons d'implémenter les bonus à l'aide de 3 classes dont
une classe abstraite permettant d'unifier le comportement commun des deux
autres.

\subsubsection{BonusPill}

La classe \texttt{BonusPill} représente une capsule/pillule de bonus contenant
un \texttt{BonusType}. Celle-ci étant rectangulaire mais ne laissant pas la
balle rebondir dessus, elle hérite seulement de \texttt{RectangleShape}. Elle
possède également une vitesse de descente. La méthode isOverlapping, héritée de
\texttt{RectangleShape} permet de vérifier si la pillule est rentrée en
collision avec un autre \texttt{RectangleShape}. Nous utilisons cette méthode
sur la raquette afin de savoir si la raquette a attrapé la \texttt{BonusPill}.
La méthode \texttt{update} permet de faire descendre le bonus de la distance
qu'il aurait parcouru après \texttt{deltaTime} secondes.

\subsubsection{ScoreManager}

La classe \texttt{ScoreManager} gère et centralise les informations concernant
le score, c'est-à-dire le meilleur score et le score du joueur à un instant T.

\subsubsection{LifeCounter}

La classe \texttt{LifeCounter} gère le nombre de vies du joueur. Toutefois, la
responsabilité de notifier les pertes et gains de vie au \texttt{LifeCounter}
revient à la \texttt{GameBoard}. Par exemple, lorsque le joueur n'a plus de
balle en jeu, \texttt{GameBoard} doit envoyer un message \texttt{LifeCounter}
pour décrémenter le nombre de vies.

\subsubsection{Lazer}

La classe \texttt{Lazer} représente un laser tiré vers le haut et provenant de
la raquette. Celui-ci est de forme rectangulaire et ne fait pas rebondir la
balle, il hérite donc uniquement de \texttt{RectangleShape}. Celui-ci possède
une vitesse. Nous utilisons la méthode isOlverapping héritée de
\texttt{RectangleShape} afin de vérifier si le laser a collisionné avec un
autre \texttt{RectangleShape}. La méthode \texttt{update} permet de faire
monter le bonus de la distance qu'il aurait parcouru après \texttt{deltaTime}
secondes.

\subsection{Vue} \subsubsection{DisplayGame} La classe \texttt{DisplayGame}
gère l'affichage global du jeu. Elle utilise la classe \texttt{Canvas} pour
dessiner les éléments et dépend de \texttt{GameBoard} pour accéder aux données
du jeu. Cette classe utilise des ressources graphiques Allegro
(\texttt{ALLEGRO\_DISPLAY}, \texttt{ALLEGRO\_BITMAP}) et des polices
(\texttt{ALLEGRO\_FONT}). Mais d'abord, elle  initialise Allegro et vérifie les
erreurs d'initialisation.

\subsubsection{Canvas} Cette classe est une plateforme centrale pour dessiner
toutes les pièces et éléments du jeu. Elle travaille avec \texttt{GameBoard}
pour accéder aux entités comme la raquette, les balles, les briques, etc. Elle
intègre des objets comme \texttt{RacketUi}, \texttt{BallUi}, \texttt{BrickUi},
et autres pour traduire l'élément modèle en élément vue qui pourra être dessiné
par Allegro. Cette classe permet de centraliser les appels de dessin pour tous
les éléments du jeu.

\subsubsection{Formes Géométriques}
\begin{itemize}

    \item \textbf{Rectangle} : Classe de base pour les objets comme
        \texttt{WallUi}, \texttt{RacketUi}, et autres.

    \item \textbf{Circle} : Classe de base pour les objets comme
        \texttt{BallUi}.

    \item \textbf{Responsabilités} :

    \begin{itemize}

        \item Gérer les attributs géométriques (position, dimensions,
            couleurs).

        \item Fournir une méthode \texttt{draw()} pour dessiner la forme.

    \end{itemize}

\end{itemize}

\subsubsection{Autres Classes}
\begin{itemize}

    \item \textbf{WallUi} : Représente les murs dans l'interface utilisateur,
        hérite de \texttt{Rectangle}.

    \item \textbf{RacketUi} : Représente la raquette du joueur, hérite de
        \texttt{Rectangle}.

    \item \textbf{LazerUi} : Représente les lasers, hérite de
        \texttt{Rectangle}.

    \item \textbf{BrickUi} : Gère l'affichage des briques, hérite de
        \texttt{Rectangle} et travaille avec \texttt{AbstractBrick}.

    \item \textbf{BonusPillUi} : Affiche les bonus tombants, hérite de
        \texttt{Rectangle}.

    \item \textbf{BallUi} : Représente les balles dans le jeu, hérite de
        \texttt{Circle}.

\end{itemize}

\subsection{Contrôleur}

La classe \texttt{ControllerGame} gère la logique principale du jeu, y compris
les événements, la progression des niveaux et l'interaction entre les éléments
du jeu. Il dépend de \texttt{GameBoard} pour toute la logique du jeu, et
interagit avec \texttt{DisplayGame} pour l'affichage. Il utilise également
\texttt{LevelManager} pour gérer les niveaux et charger leurs données. \newline

Il est responsable de gérer la boucle principale du jeu, de gérer les
événements d'entrée comme le clavier, de charger les niveaux via le
\texttt{LevelManager}, de contrôler les transitions de victoire et de défaite,
et d'interagir avec Allegro pour la gestion des événements, du timer, et de
l'affichage, tout en appelant \texttt{DisplayGame} pour dessiner l'état du jeu
en cours.

\subsection{Log}

Dans l'optique de faciliter le débogage, essentiellement pour les collisions,
nous ajoutons le singleton \texttt{Log}, permettant d'enregistrer des
évènements classés par catégories lors de l'éxécution. Nous pouvons activer ou
désactiver des catégories à la compilation en modifiant le code.

\section{Logique du jeu}

Nous allons maintenant décrire en détail ce qui se passe dans notre code à
partir du moment où l'utilisateur lance le programme, et le moment où la balle
touche une brique pour la première fois. \\

Au lancement du jeu, le programme commence par initialiser les différentes
classes nécessaires : En premier lieu, nous instancions un objet
\textit{ControllerGame}. Celui-ci permet de contrôler la grille du jeu et la
vue. Lors de sa création, \textit{ControllerGame} crée l'objet
\textit{GameBoard} représentant la grille de jeu, la partie "modèle". L'objet
\textit{LevelManager} sera également créé. Il permet de charger tous les
différents niveaux en une fois, avec les murs, la raquette et les briques. Afin
de préparer la \textit{GameBoard} pour le niveau choisi, le
\textit{LevelManager} lui passe une copie de ces différents objets à l'aide des
setters. Ensuite, il crée aussi l'objet \textit{DisplayGame} qui gère la partie
graphique du jeu. Il initialise \texttt{Allegro} pour pouvoir afficher une
fenêtre. À chaque fois que nous avons besoin d'afficher l'état du jeu,
\textit{DisplayGame} demande à \textit{GameBoard} l'état de la grille pour
l'afficher. \\

Une fois que ces différents objets sont créés, le programme installe le
nécessaire pour pouvoir utiliser le clavier et la souris dans le jeu. Puis,
\textit{ControllerGame} initialise le \textit{ALLEGRO\_TIMER} qui permet
d'avoir un "tick" à une fréquence donnée. Nous utilisons celui-ci afin de
mettre à jour la grille du jeu ainsi que pour afficher l'état du jeu à l'écran.
Nous séparons la vitesse de mise à jour de la grille du nombre d'images
affichées par Allegro à chaque seconde pour des raisons de performance. La
grille sera mise à jour 500 fois par seconde tandis qu' Allegro affichera une
image à l'écran 125 fois par seconde. \\

Ensuite, le \textit{ControllerGame} démarre le \textit{ALLEGRO\_TIMER} et à
chaque "tick" du timer, la \textit{GameBoard} et tous les objets qu'elle
possèdent sont mis à jour. A chaque mis à jour, la \textit{GameBoard} vérifie
si la balle est entrée en collision est un ou plusieurs objets. Si c'est le
cas, elle résout les collisions (\ref{lexique:resoudre_collisions}), ajuste le
score et fait apparaitre les pillules de bonus si nécessaire en les ajouttant
au vecteur prévu à cet effet. Pour les briques, elle signale également à la
brique que celle-ci est touchée. Si la durabilité de la brique est 0, celle-ci
est supprimée. Pour les pillules de bonus et les lasers, il n'y pas de
collision à résoudre, simplement faire disparaitre l'objet suffit.

A la fin de chaque mis-a-jour du \textit{ControllerGame}, le programme vérifie
s'il y a encore au moins une balle en jeu. Si ce n'est pas le cas, il retire
une vie. 

Enfin, le \textit{ControllerGame} demande au \texttt{GameBoard} le nombre de
vies et de briques non-dorées restantes. S'il n'y a plus de briques non-dorées,
le joueur a gagné. S'il ne reste aucune vie, le joueur a perdu.

Si des événements arrivent dans la \textit{queue} d'Allegro, ils seront traités
avant d'afficher le jeu à l'écran. \\

\section{Modèle-Vue-Contrôleur}

Tout au long du développement du programme, nous avons essayé le plus possible
de respecter le modèle de conception \texttt{'Modèle-Vue-Contrôleur'}. Cela
implique que notre programme soit divisé en trois parties distinctes : 

\begin{itemize}

    \item \texttt{Modèle}

    \item \texttt{Vue}

    \item \texttt{Contrôleur}

\end{itemize}

\subsection{Modèle}

Cette partie contient toute la logique pour la grille du jeu. Elle permet
d'avoir l'état de la grille et de la modifier. Elle ne possède donc rien qui
est lié à l'affichage comme Allegro. Elle permet de ne devoir uniquement gérer
la partie logique du jeu, sans devoir s'occuper d'afficher en plus l'état du
jeu. La classe \textit{GameBoard} représente l'état du jeu et possède une
méthode pour pouvoir être mise à jour.

\subsection{Vue}

La partie vue permet seulement d'afficher l'état de la grille à un moment
donné. La vue va demander au modèle son état pour l'afficher à l'écran à l'aide
de la bibliothèque Allegro. Elle ne peut donc en aucun cas modifier l'état du
jeu, donc le modèle. Toutes les méthodes de modification du modèle dans la
classe \textit{GameBoard} sont privées, ce qui garantit que la classe
\textit{DisplayGame} n'a aucun moyen de modifier \textit{GameBoard}. Les seules
méthodes publiques de \textit{GameBoard} sont des getters constants qui
assurent qu'aucune modification du modèle n'est possible.

\subsection{Contrôleur}

Cette troisième partie permet de contrôler le modèle en lui demandant de faire
certaines choses, ou en lui demandant de lui donner quelque chose. Le
contrôleur permet aussi de dire à la vue quand afficher quelque chose. Grâce à
lui, nous pouvons gérer le modèle et la vue en les séparant et les faire
fonctionner tous les deux, avec la garantie que la vue ne saura pas modifier le
modèle. C'est la classe \textit{ControllerGame} qui joue ce rôle. Elle possède
un \textit{shared pointer} vers \textit{GameBoard} pour lui demander de se
mettre à jour, et un \textit{shared pointer} vers \textit{DisplayGame} pour lui
demander d'afficher l'état du jeu.


\section{Conclusion}

Pour conclure ce rapport, nous dirons que ce projet nous a permis de développer
nos compétences en programmation orientée objet grâce au développement d'une
version fonctionnelle du jeu \texttt{Arkanoid}. L’utilisation du modèle
\texttt{Modèle-Vue-Contrôleur} a été essentielle pour nous répartir les tâches
entre nous deux, et pour structurer notre code et garantir une séparation
claire des responsabilités entre la logique du jeu, l’affichage du jeu, et le
contrôle des événements. \\

Le fait que ce projet soit un jeu avec une interface graphique nous a également
permis de prendre du plaisir à le réaliser tout en approfondissant notre
connaissance du langage \texttt{C++}.  \\

Cette expérience nous a non seulement permis de développer un programme abouti,
mais également d’affiner nos compétences en conception, en programmation et en
travail d'équipe.


\section*{Lexique}

\begin{description}

\item[Résoudre les collisions] \label{lexique:resoudre_collisions} Dû à notre
    approche pour la physique du jeu dite "discrète"
    (\ref{lexique:physique_discrete}), certains objets se retrouvent en
    superposition au lieu de collisionner (et rebondir). Résoudre les
    collisions consiste à replacer les objets à l'endroit où ils étaient juste
    avant la collision, et appliquer l'effet de rebond si nécessaire.

\item[Physique discrète] \label{lexique:physique_discrete} Simulation où le
    temps avance par étapes, ce qui peut parfois entraîner des imprécisions ou
    des chevauchements entre objets.

\end{description}



\end{document}
